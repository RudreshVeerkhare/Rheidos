from __future__ import annotations

from typing import Optional, Sequence, Tuple

import numpy as np

try:
    from panda3d.core import (
        Geom,
        GeomNode,
        GeomTriangles,
        GeomVertexData,
        GeomVertexFormat,
        GeomVertexWriter,
        NodePath,
        SamplerState,
    )
except Exception:  # pragma: no cover
    Geom = None  # type: ignore
    GeomNode = None  # type: ignore
    GeomTriangles = None  # type: ignore
    GeomVertexData = None  # type: ignore
    GeomVertexFormat = None  # type: ignore
    GeomVertexWriter = None  # type: ignore
    NodePath = None  # type: ignore
    SamplerState = None  # type: ignore

from ..abc.view import View
from ..resources.texture import Texture2D


Bounds2D = Tuple[Tuple[float, float], Tuple[float, float]]


class PointVortexStreamFunctionView(View):
    """
    Renders the 2D stream function generated by a collection of point vortices
    onto a textured quad in the scene.
    """

    def __init__(
        self,
        positions: Sequence[Sequence[float]],
        strengths: Sequence[float] | float,
        name: Optional[str] = None,
        sort: int = 0,
        bounds: Optional[Bounds2D] = None,
        resolution: Tuple[int, int] | int = (512, 512),
        plane_z: float = 0.0,
        symmetric_colormap: bool = True,
        core_radius: float = 1e-3,
        margin: float = 1.0,
    ) -> None:
        super().__init__(name=name or "PointVortexStreamView", sort=sort)

        self._positions = self._normalize_positions(positions)
        self._strengths = self._normalize_strengths(strengths, self._positions.shape[0])
        self._resolution = self._normalize_resolution(resolution)
        self._plane_z = float(plane_z)
        self._symmetric = bool(symmetric_colormap)
        self._core_radius = max(float(core_radius), 1e-6)
        self._margin = max(float(margin), 0.0)
        self._bounds = self._normalize_bounds(bounds, self._positions)
        self._has_custom_bounds = bounds is not None

        self._node: Optional[NodePath] = None
        self._texture: Optional[Texture2D] = None
        self._dirty = True

    # ---- public API -------------------------------------------------

    def set_vortices(
        self, positions: Sequence[Sequence[float]], strengths: Sequence[float] | float
    ) -> None:
        self._positions = self._normalize_positions(positions)
        self._strengths = self._normalize_strengths(strengths, self._positions.shape[0])
        if not self._has_custom_bounds:
            self._bounds = self._normalize_bounds(None, self._positions)
        self._dirty = True

    def set_bounds(self, bounds: Bounds2D) -> None:
        self._bounds = self._normalize_bounds(bounds, self._positions)
        self._has_custom_bounds = True
        self._dirty = True

    def use_auto_bounds(self) -> None:
        self._has_custom_bounds = False
        self._bounds = self._normalize_bounds(None, self._positions)
        self._dirty = True

    def set_resolution(self, resolution: Tuple[int, int] | int) -> None:
        self._resolution = self._normalize_resolution(resolution)
        self._dirty = True

    # ---- View lifecycle ---------------------------------------------

    def setup(self, session) -> None:
        super().setup(session)
        if Geom is None or GeomVertexData is None or NodePath is None:
            return

        self._texture = Texture2D(self.name + "-stream")
        self._update_texture()

        node = self._build_quad()
        if node is None:
            return
        self._node = node

        if self._texture is not None:
            tex = self._texture.tex
            if SamplerState is not None:
                try:
                    tex.setMinfilter(SamplerState.FT_linear)
                    tex.setMagfilter(SamplerState.FT_linear)
                    tex.setWrapU(SamplerState.WM_clamp)
                    tex.setWrapV(SamplerState.WM_clamp)
                except Exception:
                    pass
            node.setTexture(tex, 1)
        node.setShaderAuto()
        node.setTwoSided(True)

    def update(self, dt: float) -> None:
        if self._dirty:
            self._update_texture()

    def teardown(self) -> None:
        if self._node is not None:
            self._node.removeNode()
            self._node = None
        self._texture = None
        self._dirty = False

    def on_enable(self) -> None:
        if self._node is not None:
            self._node.show()

    def on_disable(self) -> None:
        if self._node is not None:
            self._node.hide()

    # ---- internals --------------------------------------------------

    def _normalize_positions(self, positions: Sequence[Sequence[float]]) -> np.ndarray:
        arr = np.asarray(list(positions), dtype=float)
        if arr.ndim == 1:
            arr = np.atleast_2d(arr)
        if arr.size == 0:
            raise ValueError("At least one vortex position is required.")
        if arr.shape[1] < 2:
            raise ValueError("Positions must include at least X and Y components.")
        if arr.shape[1] > 2:
            arr = arr[:, :2]
        return arr.astype(np.float64, copy=False)

    def _normalize_strengths(self, strengths: Sequence[float] | float, count: int) -> np.ndarray:
        arr = np.asarray(strengths, dtype=float)
        if arr.ndim == 0:
            arr = np.full((count,), float(arr), dtype=float)
        if arr.shape[0] != count:
            raise ValueError("Strength count must match the number of positions.")
        return arr.astype(np.float64, copy=False)

    def _normalize_resolution(self, resolution: Tuple[int, int] | int) -> tuple[int, int]:
        if isinstance(resolution, int):
            res_x = res_y = int(resolution)
        else:
            res_x = int(resolution[0])
            res_y = int(resolution[1])
        if res_x < 2 or res_y < 2:
            raise ValueError("Resolution must be at least 2x2.")
        return (res_x, res_y)

    def _normalize_bounds(self, bounds: Optional[Bounds2D], positions: np.ndarray) -> Bounds2D:
        if bounds is not None:
            (x0, y0), (x1, y1) = bounds
            if x1 <= x0 or y1 <= y0:
                raise ValueError("Bounds must define a positive area.")
            return ((float(x0), float(y0)), (float(x1), float(y1)))

        mins = positions.min(axis=0) - self._margin
        maxs = positions.max(axis=0) + self._margin
        if np.isclose(mins[0], maxs[0]):
            mins[0] -= 0.5
            maxs[0] += 0.5
        if np.isclose(mins[1], maxs[1]):
            mins[1] -= 0.5
            maxs[1] += 0.5
        return ((float(mins[0]), float(mins[1])), (float(maxs[0]), float(maxs[1])))

    def _build_quad(self) -> Optional[NodePath]:
        if self._session is None or GeomVertexData is None or GeomVertexFormat is None:
            return None
        (x0, y0), (x1, y1) = self._bounds

        vdata = GeomVertexData(self.name + "-stream-quad", GeomVertexFormat.getV3t2(), Geom.UHStatic)
        vw = GeomVertexWriter(vdata, "vertex")
        tw = GeomVertexWriter(vdata, "texcoord")
        z = self._plane_z

        vw.addData3f(x0, y0, z)
        tw.addData2f(0.0, 0.0)
        vw.addData3f(x1, y0, z)
        tw.addData2f(1.0, 0.0)
        vw.addData3f(x1, y1, z)
        tw.addData2f(1.0, 1.0)
        vw.addData3f(x0, y1, z)
        tw.addData2f(0.0, 1.0)

        prim = GeomTriangles(Geom.UHStatic)
        prim.addVertices(0, 1, 2)
        prim.addVertices(0, 2, 3)
        prim.closePrimitive()

        geom = Geom(vdata)
        geom.addPrimitive(prim)

        node = GeomNode(self.name + "-geom")
        node.addGeom(geom)
        np_node = self._session.render.attachNewNode(node)
        np_node.setName(self.name)
        return np_node

    def _update_texture(self) -> None:
        if self._texture is None:
            return
        image = self._generate_image()
        self._texture.from_numpy_rgba(image)
        self._dirty = False

    def _generate_image(self) -> np.ndarray:
        res_x, res_y = self._resolution
        (x0, y0), (x1, y1) = self._bounds

        xs = np.linspace(x0, x1, res_x, dtype=np.float64)
        ys = np.linspace(y0, y1, res_y, dtype=np.float64)
        grid_x, grid_y = np.meshgrid(xs, ys)

        psi = np.zeros_like(grid_x, dtype=np.float64)
        core_sq = self._core_radius * self._core_radius
        for pos, gamma in zip(self._positions, self._strengths):
            dx = grid_x - pos[0]
            dy = grid_y - pos[1]
            r_sq = dx * dx + dy * dy + core_sq
            psi += (float(gamma) / (4.0 * np.pi)) * np.log(r_sq)

        if self._symmetric:
            scale = float(np.max(np.abs(psi)))
            if scale < 1e-9:
                scale = 1.0
            norm = 0.5 + 0.5 * (psi / scale)
        else:
            psi_min = float(np.min(psi))
            psi_max = float(np.max(psi))
            if abs(psi_max - psi_min) < 1e-9:
                norm = np.full_like(psi, 0.5, dtype=np.float64)
            else:
                norm = (psi - psi_min) / (psi_max - psi_min)

        norm = np.clip(norm, 0.0, 1.0)
        return self._apply_diverging_colormap(norm)

    def _apply_diverging_colormap(self, values: np.ndarray) -> np.ndarray:
        blue = np.array([40, 80, 200], dtype=np.float64)
        white = np.array([245, 245, 245], dtype=np.float64)
        red = np.array([200, 50, 30], dtype=np.float64)

        vals = values.astype(np.float64, copy=False)
        image = np.empty(vals.shape + (4,), dtype=np.uint8)

        lower_mask = vals <= 0.5
        if np.any(lower_mask):
            alpha = (vals[lower_mask] / 0.5)[..., None]
            rgb = (1.0 - alpha) * blue + alpha * white
            image[lower_mask, :3] = np.clip(rgb, 0, 255).astype(np.uint8)

        upper_mask = ~lower_mask
        if np.any(upper_mask):
            alpha = ((vals[upper_mask] - 0.5) / 0.5)[..., None]
            rgb = (1.0 - alpha) * white + alpha * red
            image[upper_mask, :3] = np.clip(rgb, 0, 255).astype(np.uint8)

        image[..., 3] = 255
        return image
